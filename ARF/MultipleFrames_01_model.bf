RequireVersion ("2.00");LoadFunctionLibrary ("chooseGeneticCode");stops = (_Genetic_Code["_MATRIX_ELEMENT_VALUE_==10"] * Transpose (_Genetic_Code["1"]))[0];sense = 64-stops;global AC = 1;global AT = 1;global CG = 1;global CT = 1;global GT = 1;_nucRateMultipliers = {4,4};_nucRateMultipliers [0][0] = "";_nucRateMultipliers [0][1] = "AC*";_nucRateMultipliers [1][0] = "AC*";_nucRateMultipliers [0][2] = "";_nucRateMultipliers [2][0] = "";_nucRateMultipliers [0][3] = "AT*";_nucRateMultipliers [3][0] = "AT*";_nucRateMultipliers [1][2] = "CG*";_nucRateMultipliers [2][1] = "CG*";_nucRateMultipliers [1][3] = "CT*";_nucRateMultipliers [3][1] = "CT*";_nucRateMultipliers [2][3] = "GT*";_nucRateMultipliers [3][2] = "GT*";ns_rate_types	= 5;TRY_NUMERIC_SEQUENCE_MATCH = 1;/*-----------------------------------------------------------------------------------------*/function PrepareTemplates (){	/* substitution types, conditional on flanking nucleotides can be:		0  - SS		1  - SN		2  - NS		3  - NN	*/	hShift 	  = 0;	nuc_split = {2,3};	F0_stencil_1  = {};	F0_stencil_23 = {};	F1_stencil_12 = {};	F1_stencil_3  = {};	 	for (h = 0; h<64; h=h+1)	{		AA1 = _Genetic_Code[h];		if (AA1 == 10)		{			hShift = hShift+1;		}		else		{			nuc_split[0][0] = h$16;			nuc_split[0][1] = (h%16)$4;			nuc_split[0][2] = h%4;						vShift = hShift;						for (v = h+1; v<64; v=v+1)			{				AA2 = _Genetic_Code[v];				if (AA2 == 10)				{					vShift = vShift+1;				}				else				{					nuc_split[1][0] = v$16;					nuc_split[1][1] = (v%16)$4;					nuc_split[1][2] = v%4;										subPair = {{h,v}};										diff = (nuc_split[0][-1] - nuc_split[1][-1])["_MATRIX_ELEMENT_VALUE_!=0"];										if ( (diff * Transpose (diff["1"]))[0] == 1) /* one nucleotide different */					{						F0_type   = (AA1!=AA2); /* kind of substitution in frame 0 */												if (diff[0])						{							F0_cond_1 	= {16,1};														for (p1 = 0; p1 < 16; p1 = p1+1)							{								t1 = 4*p1 + nuc_split[0][0];								t2 = 4*p1 + nuc_split[1][0];																	if (_Genetic_Code[t1] == 10 || _Genetic_Code[t2] == 10)								{									F0_cond_1  [p1] = 4;								}								else								{									F0_cond_1  [p1] = F0_type * 2 + (_Genetic_Code[t1] != _Genetic_Code[t2]);								}							}														F0_stencil_1 [subPair] = F0_cond_1;						}						else						{							F0_cond_23 = {4,1};								for (p1 = 0; p1 < 4; p1 = p1+1)							{								t1 = 4*(4*nuc_split[0][1]+nuc_split[0][2]) + p1;								t2 = 4*(4*nuc_split[1][1]+nuc_split[1][2]) + p1;								if (_Genetic_Code[t1] == 10 || _Genetic_Code[t2] == 10)								{									F0_cond_23 [p1] = 4;								}								else								{									F0_cond_23 [p1] = F0_type * 2 + (_Genetic_Code[t1] != _Genetic_Code[t2]);								}							}														F0_stencil_23 [subPair] = F0_cond_23;						}						if (diff[2] == 0)						{							F1_cond_12 = {4,1};								for (p1 = 0; p1 < 4; p1 = p1+1)							{								t1 = 4*nuc_split[0][0]+nuc_split[0][1] + p1*16;								t2 = 4*nuc_split[1][0]+nuc_split[1][1] + p1*16;								if (_Genetic_Code[t1] == 10 || _Genetic_Code[t2] == 10)								{									F1_cond_12 [p1] = 4;								}								else								{									F1_cond_12 [p1] = F0_type +  2 * (_Genetic_Code[t1] != _Genetic_Code[t2]);								}							}														F1_stencil_12 [subPair] = F1_cond_12;						}						else						{							F1_cond_3 = {16,1};								for (p1 = 0; p1 < 16; p1 = p1+1)							{								t1 = 16*nuc_split[0][2] + p1;								t2 = 16*nuc_split[1][2] + p1;								if (_Genetic_Code[t1] == 10 || _Genetic_Code[t2] == 10)								{									F1_cond_3 [p1] = 4;								}								else								{									F1_cond_3 [p1] = F0_type +  2 * (_Genetic_Code[t1] != _Genetic_Code[t2]);								}							}														F1_stencil_3 [subPair] = F1_cond_3;						}					}				}			}		}	}	return 0;}/*-----------------------------------------------------------------------------------------*/function PopulateModelMatrixF0 (MatrixID &, EFV){	global R_01 = 1;	global R_10 = 1;	global R_11 = 1;	global R_ST = 1;		MatrixID  = {sense, sense};	hShift 	  = 0;	nuc_split = {2,3};		defString = "";	defString * 8192;	rateTags = {ns_rate_types,1};	rateTags [0] = "1";	rateTags [1] = "R_01";	rateTags [2] = "R_10";	rateTags [3] = "R_11";	rateTags [4] = "R_ST";	for (h = 0; h<64; h=h+1)	{		AA1 = _Genetic_Code[h];		if (AA1 == 10)		{			hShift = hShift+1;		}		else		{			nuc_split[0][0] = h$16;			nuc_split[0][1] = (h%16)$4;			nuc_split[0][2] = h%4;						vShift = hShift;						for (v = h+1; v<64; v=v+1)			{				AA2 = _Genetic_Code[v];				if (AA2 == 10)				{					vShift = vShift+1;				}				else				{					nuc_split[1][0] = v$16;					nuc_split[1][1] = (v%16)$4;					nuc_split[1][2] = v%4;										subPair = {{h,v}};										diff = (nuc_split[0][-1] - nuc_split[1][-1])["_MATRIX_ELEMENT_VALUE_!=0"];										if ( (diff * Transpose (diff["1"]))[0] == 1) /* one nucleotide different */					{						if (diff[0])						{							stencil    = F0_stencil_1[subPair];							strings    = {{"","","","",""}};							js		   = "synRate*(";														for (k=0; k<16; k=k+1)							{								strings [stencil[k]] = strings [stencil[k]] + "(c_23==" + k + ")+";							}														diff = 0;							AA2  = 0;							for (k=0; k<ns_rate_types; k=k+1)							{								sl = Abs(strings[k]);								if (sl)								{									diff = diff + 1;									if (diff > 1)									{										js = js + "+(" + (strings[k])[0][Abs(strings[k])-2] + ")*" + rateTags[k];									}									else									{										js = js + "(" + (strings[k])[0][Abs(strings[k])-2] + ")*" + rateTags[k];																	}									AA2	 = k;								}							}														if (diff == 1)							{								js = "synRate*" + rateTags [AA2];							}							else							{								js = js + ")";							}														defString * ("MatrixID["+(h-hShift) + "][" + (v-vShift) + "] := " +_nucRateMultipliers[nuc_split[0][0]][nuc_split[1][0]] 																							  + js + "*EFV__[" + nuc_split[1][0] + "][0];\n");							defString * ("MatrixID["+(v-vShift) + "][" + (h-hShift) + "] := " +_nucRateMultipliers[nuc_split[0][0]][nuc_split[1][0]] 																							  + js + "*EFV__[" + nuc_split[0][0] + "][0];\n");						}						else						{							stencil    = F0_stencil_23[subPair];							strings    = {{"","","","",""}};							js		   = "synRate*(";														for (k=0; k<4; k=k+1)							{								strings [stencil[k]] = strings [stencil[k]] + "(c_1==" + k + ")+";							}														subPair = diff[1] + 2*diff[2];														diff = 0;							AA2  = 0;							for (k=0; k<ns_rate_types; k=k+1)							{								sl = Abs(strings[k]);								if (sl)								{									diff = diff + 1;									if (diff > 1)									{										js = js + "+(" + (strings[k])[0][Abs(strings[k])-2] + ")*" + rateTags[k];									}									else									{										js = js + "(" + (strings[k])[0][Abs(strings[k])-2] + ")*" + rateTags[k];																	}									AA2	 = k;								}							}														if (diff == 1)							{								js = "synRate*" + rateTags [AA2];							}							else							{								js = js + ")";							}																					defString * ("MatrixID["+(h-hShift) + "][" + (v-vShift) + "] := "+_nucRateMultipliers[nuc_split[0][subPair]][nuc_split[1][subPair]] 																						     + js + "*EFV__[" + nuc_split[1][subPair] + "]["+subPair+"];\n");																						     							defString * ("MatrixID["+(v-vShift) + "][" + (h-hShift) + "] := "+_nucRateMultipliers[nuc_split[0][subPair]][nuc_split[1][subPair]]  																							 + js + "*EFV__[" + nuc_split[0][subPair] + "]["+subPair+"];\n");												}					}				}			}		}	}		defString * 0;	ExecuteCommands (defString);		return 0;}/*-----------------------------------------------------------------------------------------*/function PopulateModelMatrixF1 (MatrixID &, EFV){	global R_01 = 1;	global R_10 = 1;	global R_11 = 1;	global R_ST = 1;		MatrixID  = {sense, sense};	hShift 	  = 0;	nuc_split = {2,3};		defString = "";	defString * 8192;	rateTags = {ns_rate_types,1};	rateTags [0] = "1";	rateTags [1] = "R_01";	rateTags [2] = "R_10";	rateTags [3] = "R_11";	rateTags [4] = "R_ST";	for (h = 0; h<64; h=h+1)	{		AA1 = _Genetic_Code[h];		if (AA1 == 10)		{			hShift = hShift+1;		}		else		{			nuc_split[0][0] = h$16;			nuc_split[0][1] = (h%16)$4;			nuc_split[0][2] = h%4;						vShift = hShift;						for (v = h+1; v<64; v=v+1)			{				AA2 = _Genetic_Code[v];				if (AA2 == 10)				{					vShift = vShift+1;				}				else				{					nuc_split[1][0] = v$16;					nuc_split[1][1] = (v%16)$4;					nuc_split[1][2] = v%4;										subPair = {{h,v}};										diff = (nuc_split[0][-1] - nuc_split[1][-1])["_MATRIX_ELEMENT_VALUE_!=0"];										if ( (diff * Transpose (diff["1"]))[0] == 1) /* one nucleotide different */					{						if (diff[2])						{							stencil    = F1_stencil_3[subPair];							strings    = {{"","","","",""}};							js		   = "synRate*(";														for (k=0; k<16; k=k+1)							{								strings [stencil[k]] = strings [stencil[k]] + "(c_23==" + k + ")+";							}														diff = 0;							AA2  = 0;							for (k=0; k<ns_rate_types; k=k+1)							{								sl = Abs(strings[k]);								if (sl)								{									diff = diff + 1;									if (diff > 1)									{										js = js + "+(" + (strings[k])[0][Abs(strings[k])-2] + ")*" + rateTags[k];									}									else									{										js = js + "(" + (strings[k])[0][Abs(strings[k])-2] + ")*" + rateTags[k];																	}									AA2	 = k;								}							}														if (diff == 1)							{								js = "synRate*" + rateTags [AA2];							}							else							{								js = js + ")";							}														defString * ("MatrixID["+(h-hShift) + "][" + (v-vShift) + "] := " +_nucRateMultipliers[nuc_split[0][2]][nuc_split[1][2]] 																							  + js + "*EFV__[" + nuc_split[1][2] + "][2];\n");							defString * ("MatrixID["+(v-vShift) + "][" + (h-hShift) + "] := " +_nucRateMultipliers[nuc_split[0][2]][nuc_split[1][2]] 																							  + js + "*EFV__[" + nuc_split[0][2] + "][2];\n");						}						else						{							stencil    = F1_stencil_12[subPair];							strings    = {{"","","","",""}};							js		   = "synRate*(";														for (k=0; k<4; k=k+1)							{								strings [stencil[k]] = strings [stencil[k]] + "(c_1==" + k + ")+";							}																					subPair = diff[1];														diff = 0;							AA2  = 0;							for (k=0; k<ns_rate_types; k=k+1)							{								sl = Abs(strings[k]);								if (sl)								{									diff = diff + 1;									if (diff > 1)									{										js = js + "+(" + (strings[k])[0][Abs(strings[k])-2] + ")*" + rateTags[k];									}									else									{										js = js + "(" + (strings[k])[0][Abs(strings[k])-2] + ")*" + rateTags[k];																	}									AA2	 = k;								}							}														if (diff == 1)							{								js = "synRate*" + rateTags [AA2];							}							else							{								js = js + ")";							}																					defString * ("MatrixID["+(h-hShift) + "][" + (v-vShift) + "] := "+_nucRateMultipliers[nuc_split[0][subPair]][nuc_split[1][subPair]] 																						     + js + "*EFV__[" + nuc_split[1][subPair] + "]["+subPair+"];\n");																						     							defString * ("MatrixID["+(v-vShift) + "][" + (h-hShift) + "] := "+_nucRateMultipliers[nuc_split[0][subPair]][nuc_split[1][subPair]]  																							 + js + "*EFV__[" + nuc_split[0][subPair] + "]["+subPair+"];\n");												}					}				}			}		}	}		defString * 0;	ExecuteCommands (defString);		return 0;	}/*---------------------------------------------------------------------------------------------------------------------------------------------*/function BuildCodonFrequencies (obsF){	PIStop = 1.0;	result = {sense,1};	hshift = 0;	for (h=0; h<64; h=h+1)	{		first = h$16;		second = h%16$4;		third = h%4;		if (_Genetic_Code[h]==10) 		{			hshift = hshift+1;			PIStop = PIStop-obsF[first][0]*obsF[second][1]*obsF[third][2];			continue; 		}		result[h-hshift][0]=obsF[first][0]*obsF[second][1]*obsF[third][2];	}	return result*(1.0/PIStop);}/*-----------------------------------------------------------------------------------------*/PrepareTemplates    ();SetDialogPrompt ("Select a codon file with overlapping reading frames:");DataSet	ds 		 = ReadDataFile (PROMPT_FOR_FILE);fPath		     = LAST_FILE_PATH;DataSetFilter F0 	= CreateFilter (ds,3,"","",GeneticCodeExclusions);DataSetFilter F1 	= CreateFilter (ds,3,siteIndex>0,"",GeneticCodeExclusions);HarvestFrequencies (EFVF0,F0,3,1,1);HarvestFrequencies (EFVF1,F1,3,1,1);DataSetFilter aux   = CreateFilter (ds,1,"<011>");HarvestFrequencies (f23,aux,2,2,1);DataSetFilter aux   = CreateFilter (ds,1,"<100>");HarvestFrequencies (f1,aux,1,1,1);category 	c_1  = (4,f1,MEAN, , {{0,1,2,3}}, 0, 3);category 	c_23 = (16,f23,MEAN, , {{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}}, 0, 15);codonFreqsF0  = BuildCodonFrequencies (EFVF0);codonFreqsF1  = BuildCodonFrequencies (EFVF1);ExecuteAFile (HYPHY_LIB_DIRECTORY + "TemplateBatchFiles" + DIRECTORY_SEPARATOR + "queryTree.bf");SetParameter (STATUS_BAR_STATUS_STRING, "SETTING UP THE MODELS", 0);PopulateModelMatrixF0 ("MG_Q_F0",EFVF0);Model 			MG_F0 = (MG_Q_F0, codonFreqsF0, 0);Tree  			T_F0  = treeString;PopulateModelMatrixF1 ("MG_Q_F1",EFVF1);Model 			MG_F1 = (MG_Q_F1, codonFreqsF1, 0);Tree  			T_F1  = treeString;AT:=AC;CG:=AC;CT:=1;GT:=AC;slfo = LIKELIHOOD_FUNCTION_OUTPUT;SetParameter (STATUS_BAR_STATUS_STRING, "CREATING THE LIKELIHOOD FUNCTION", 0);LikelihoodFunction lf = (F0,T_F0, F1, T_F1);SetParameter (STATUS_BAR_STATUS_STRING, "OPTIMIZING THE LIKELIHOOD FUNCTION", 0);VERBOSITY_LEVEL = 1;Optimize (res, lf);lfSave = fPath + ".full";LIKELIHOOD_FUNCTION_OUTPUT = 7;fprintf (lfSave, CLEAR_FILE,lf);LIKELIHOOD_FUNCTION_OUTPUT = slfo;fprintf  (stdout, "Fit results:\n", lf);fprintf  (stdout, "\nH0: Testing R_11 >= Min (R_01, R_10)\n");global M_Min = 1;M_Min:>1;R_11 := M_Min*Min (R_01, R_10);Optimize (res_2, lf);lfSave = fPath + ".R_11";LIKELIHOOD_FUNCTION_OUTPUT = 7;fprintf (lfSave, CLEAR_FILE,lf);LIKELIHOOD_FUNCTION_OUTPUT = slfo;fprintf  (stdout, "\nFit results:\n", lf, "\np-value = ", 0.5(1-CChi2(2(res[1][0]-res_2[1][0]),1)), "\n\n");fprintf  (stdout, "\nH0: Testing R_ST = 0\n");ClearConstraints (R_11);R_ST := 0;Optimize (res_3, lf);lfSave = fPath + ".R_ST";LIKELIHOOD_FUNCTION_OUTPUT = 7;fprintf (lfSave, CLEAR_FILE,lf);LIKELIHOOD_FUNCTION_OUTPUT = slfo;fprintf  (stdout, "\nFit results:\n", lf, "\np-value = ", 0.5(1-CChi2(2(res[1][0]-res_3[1][0]),1)), "\n\n");fprintf  (stdout, "\nH0: Testing R_01 = R_10\n");ClearConstraints (R_ST);R_01 := R_10;Optimize (res_4, lf);lfSave = fPath + ".R_01_R_10";LIKELIHOOD_FUNCTION_OUTPUT = 7;fprintf (lfSave, CLEAR_FILE,lf);LIKELIHOOD_FUNCTION_OUTPUT = slfo;fprintf  (stdout, "\nFit results:\n", lf, "\np-value = ", 1-CChi2(2(res[1][0]-res_4[1][0]),1), "\n\n");